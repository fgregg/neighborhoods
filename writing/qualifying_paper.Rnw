\documentclass[12pt,letter]{article}
\usepackage{amsmath}
\usepackage{url}
\usepackage{tikz}
\usepackage{adjustbox}

\usetikzlibrary{arrows}
\usetikzlibrary{bayesnet}

\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\argmax}{\arg\!\max}

\begin{document}

<<include=FALSE>>=
library(xtable)
opts_chunk$set(echo=FALSE, 
               fig.width=4.5, 
               fig.height=4.75, 
               fig.align="center",
               fig.pos="h!",
               fig.path='/home/fgregg/sweave-cache/figs/', 
               cache.path='/home/fgregg/sweave-cache/values/', 
               dev='tikz',
               cache=TRUE) 

inline_hook <- function(x) {
    if(is.numeric(x)) {
      x <- formatC(round(x, 2), big.mark=",", format="d")
      paste(x, collapse=", ")
    }
    else {
      x
    }
  }
knit_hooks$set(inline = inline_hook)
@


<<preamble, cache=FALSE>>= 
setwd('/home/fgregg/academic/neighborhoods/writing/')
default_margins = par("mar")
CURDIR <- "/home/fgregg/academic/neighborhoods/writing"
@ 



\section*{Introduction}
Social scientists have collected a wide and sophisticated arsenal of
ways to group similar elements of network. However, except in simplest
cases, what determines the output is the simple, iterative algorithm
of the researcher fiddling with weights until the groupings look how
she wants them to. Our methods to group similar elements depends on us
knowing what similarity means in our network. We usually don't.

When our similarity is binary, i.e. did ego nominate
alter as friend, life is easy. But, as soon as a variable has more
than two possible values then the researcher must decide how to turn
those values into similarities. Different, reasonable choices will
lead to different groupings. A careful researcher may check
her choices for robustness, but may only learn that her errors are
robust. The difficulties grow combinatorially if we decide that
a second, third, or more variable might be of some interest.

In the end, we adjust the various weights until the groupings come out
looking about right. We would have been better off just drawing what
we wanted in the first place.

We would be better off because we humans are all too good at
apprehending an assortment of things as a group than we are at
assigning importance to variables by manually assigning weights, which
we are very, very bad at.

While the interestingness of apprehended unities may vary 
unfairly between individual sociologists (not every one has Weberian gift),
we are professionally required to be interested in the way that a
collection of people groups themselves.

If we can collect information on how people group themselves, then we
can learn what counts for similarity for these people. Understanding
what similarity means for is not only scientifically interesting in
itself, it will also allow for principles prediction of how similar
collections of people will group themselves.

In this paper I discuss how to do learn about similarity using the
case of city neighborhoods. 

\input{theory_and_math.tex}

\section*{Results}
So much for theory, let's see how this works in practice. Let's take
the case of Chicago neighborhoods.  

\subsection*{Data}
<<loadFeatures, include=FALSE, cache=TRUE>>= 
setwd('../code/training/')
source('features.R')
setwd(CURDIR)
@ 


I have a nightly updated database of geocoded Craigslist apartment
rentals, sublet, and roommate listings. For most of these listings,
the poster entered some text in a ``Specific Location'' field. With
some minimal pre-processing, we can use these data as observations of
claims that geographical points are in some neighborhood.

Using kernel density estimation, we can use this point data to
estimate a continuous probability distributions that any point in the
city will be claimed to be in any of the neighborhoods (Figure
\ref{fig:KDE}). The gray lines indicate the best guess about the
neighborhood boundaries.


\begin{figure}
\includegraphics{/home/fgregg/academic/neighborhoods/writing/probability}
\caption{KDE probability estimates of neighborhood claims on North Side}
\label{fig:KDE}
\end{figure}

Using information about the location of rivers, railroad embankments,
highways, and major streets, we can smooth this estimate. 

\begin{figure}
\includegraphics{./respect_grid.pdf}
\caption{Hand tuned smoothed neighborhoods}
\end{figure}

I would like to treat this measure as a kind of `averaged neighborhood
perception.' Of course, it's biased measure of that. There are
enormous selection effects, but perhaps more troublesome is that
listers are likely to choose neighborhood claims strategically in
order to make a listing maximally desirable. I have been looking for
scientific samples of neighborhood perception that I can compare
against so as to get a sense of magnitude of the biases.

However, I think it's possible that these data, with their biases
might be good enough, and we'll have ways of checking that. 

In addition to these data about neighborhood perception, we also have
block level census data as well as a trove of unaggregated data from
the City of Chicago on the built environment, crimes, 311 reports,
zoning, and the similar. We'd like to set them in relation to each
other.

\section*{Data Details}
The ultimate units of measurement are U.S. Census blocks the edges
between them. The U.S. Census blocks mainly correspond to city face
blocks. We use a rook adjacency to define the edges, i.e. all edges
are between blocks that share a common border of length greater than
0. In the training data, there are \Sexpr{dim(blocks.poly)[1]} blocks and
  \Sexpr{dim(features)[1]} edges.

For the inter-block similarities, we will use physical, demographic,
and administrative features.

\subsection*{Physical Barriers}
Highways, rail lines, rivers, and major streets can act as convenient
neighborhood boundaries. For each of these types of features, we code
an edge feature variable as 1 if the two adjacent blocks are separated
by the feature or code and 0 otherwise.

We also measure the difference in orientation between blocks. Blocks
are nearly all longer than they are wide, and we calculate the angle
of the longest side. For each edge, we calculate the difference
between the orientations of the blocks. We normalize the difference to
fall in $[0,1]$. 

\subsection*{School Boundaries}
If two adjacent blocks are in different elementary school attendance
boundary then we code an edge feature with 1, 0 otherwise. Similar for
high schools.

\subsection*{Demographic Features}

From the U.S. Census, we have block level information on race, age,
family structure, and housing ownership patterns. We can define
measures between blocks for these data. 

The measure we will use is the Jensen Shannon Divergence, which is a
symmetric measure of the distance between distributions that ranges from
0 to 1. 

For race, the distribution is the number people coded by the Census as
``Hispanic or Latino'', ``Not Hispanic or Latino : White alone'',
``Not Hispanic or Latino : Black Alone'', and ``Not Hispanic or Latino
: Asian alone.'' 

For age, the distribution is the number of people
under 5, between 5 and 17, between 18 and 20, between 21 and 29,
between 30 and 64, and over 85. These age ranges were chosen to
capture life stages that tend to be spatially segregated: preschool,
school age, college age, young adult, middle age, retired. 

For family structure, the distribution is ``Husband-wife family'',
``Male householder, no wife present'', ``Female householder, no
husband present'', ``Householder, living alone'', and ``Householder,
not living alone''.

Many blocks have no one living in them or only a handful. In such
cases, it makes little sense to compare say racial composition. If
either adjacent blocks has fewer than 30 persons living in it, we do
not calculate the Jensen-Shannon divergences. There are
\Sexpr{sum(features$sufficient_pop)} edges where we calculate these
demographic similarities.


<<featureTable, echo=FALSE, results='asis'>>= 
feature_summary <- data.frame(sufficient.population=c(mean(features$sufficient_pop), 
                                rep(NA, 5)),
                              rail = c(mean(features$rail), 
                                rep(NA, 5)),
                              highway = c(mean(features$highway), 
                                rep(NA, 5)),
                              water = c(mean(features$water), 
                                rep(NA, 5)),
                              zoning = c(mean(features$zoning), 
                                rep(NA, 5)),
                              elementary.school = c(mean(features$elementary_school), 
                                rep(NA, 5)),
                              high.school = c(mean(features$high_school), 
                                rep(NA, 5)),
                              grid.street = c(mean(features$grid_street), 
                                rep(NA, 5)),
                              age.js=c(mean(features$js_age[features$sufficient_pop==1]), 
                                quantile(features$js_age[features$sufficient_pop==1])),
                              race.js=c(mean(features$js_race[features$sufficient_pop==1]), 
                                quantile(features$js_race[features$sufficient_pop==1])),
                              housing.js=c(mean(features$js_housing[features$sufficient_pop==1]), 
                                quantile(features$js_housing[features$sufficient_pop==1])),
                              block.angle=c(mean(features$block_angle[features$sufficient_pop==1]), 
                                quantile(features$block_angle[features$sufficient_pop==1])),
                              family.js=c(mean(features$js_family[features$sufficient_pop==1]), 
                                quantile(features$js_family[features$sufficient_pop==1]))
                              
                              )
feature_summary <- xtable(t(feature_summary))
colnames(feature_summary) <- c("Mean", "Min", "25th Quant.", "Median", "75th Quant.", "Max")
print(feature_summary)
@ 

\begin{figure}
<<railImage, dev='pdf'>>= 
plot(all_edges$lines, col=c("#00000022", "red")[features$rail + 1])
@ 
\caption{Rail Lines}
\end{figure}

\begin{figure}
<<highwayImage, dev='pdf'>>= 
plot(all_edges$lines, col=c("#00000022", "red")[features$highway + 1])
@ 
\caption{Highways}
\end{figure}

\begin{figure}
<<gridImage, dev='pdf'>>= 
plot(all_edges$lines, col=c("#00000022", "red")[features$grid_street + 1])
@ 
\caption{Major Streets}
\end{figure}

\begin{figure}
<<waterImage, dev='pdf'>>= 
plot(all_edges$lines, col=c("#00000022", "red")[features$water + 1])
@ 
\caption{River}
\end{figure}

\begin{figure}
<<elementaryImage, dev='pdf'>>= 
plot(all_edges$lines, col=c("#00000022", "red")[features$elementary_school + 1])
@ 
\caption{Elementary School Attendance Boundaries}
\end{figure}

\begin{figure}
<<highschoolImage, dev='pdf'>>= 
plot(all_edges$lines, col=c("#00000022", "red")[features$high_school + 1])
@ 
\caption{High School Attendance Boundaries}
\end{figure}

\begin{figure}
<<sufficientImage, dev='pdf'>>= 
plot(all_edges$lines, col=c("#00000022", "red")[features$sufficient_pop + 1])
@ 
\caption{Sufficient Population}
\end{figure}


\begin{figure}
<<blockAngleImage, dev='pdf'>>= 
plot(all_edges$lines, col=rgb(colorRamp(c("lightgrey", "red"))(features$block_angle)/255))
@ 
\caption{Difference in Block Orientation}
\end{figure}

\begin{figure}
<<<raceImage, dev='pdf'>>=
plot(all_edges$lines[features$sufficient_pop==1], col=rgb(colorRamp(c("lightgrey", "red"))(features$js_race[features$sufficient_pop==1])/255))
@ 
\caption{Difference in Distribution of Race and Ethnicity}
\end{figure}


\begin{figure}
<<<ageImage, dev='pdf'>>=
plot(all_edges$lines[features$sufficient_pop==1], col=rgb(colorRamp(c("lightgrey", "red"))(features$js_age[features$sufficient_pop==1])/255))
@ 
\caption{Difference in Distribution of Age}
\end{figure}


\begin{figure}
<<<familyImage, dev='pdf'>>=
plot(all_edges$lines[features$sufficient_pop==1], col=rgb(colorRamp(c("lightgrey", "red"))(features$js_family[features$sufficient_pop==1])/255))
@ 
\caption{Difference in Distribution of Family Type}
\end{figure}


\begin{figure}
<<<housingImage, dev='pdf'>>=
plot(all_edges$lines[features$sufficient_pop==1], col=rgb(colorRamp(c("lightgrey", "red"))(features$js_housing[features$sufficient_pop==1])/255))
@ 
\caption{Difference in Distribution of Housing Type}
\end{figure}

\section*{Modeling}
We'd handle the empty or sparsely populated block by using a dummy
variable to effectively learned two model at once. The non-populated
block model is 

\begin{align}
&\operatorname{E}(\mathbf{y}, \mathbf{s}, \mathbf{w}) = \sum_{<i
    j>}^{\mathcal{N}}\epsilon_{i,j}(y_i, y_j, \mathbf{s}_{i,j}, \mathbf{w})  
\end{align}

\begin{equation}
\epsilon_{i,j}(y_i, y_j, \mathbf{s}_{i,j}, \mathbf{w}) = \begin{cases}
    0 \quad\quad\quad y_i = y_j \\
    \phi(\mathbf{s}_{i,j}, \mathbf{w}) \quad y_i \neq y_j \\
  \end{cases}
\end{equation}

\begin{align}
\phi(\mathbf{s}_{i,j}, \mathbf{w}) = & w_0 
                                     + w_1\text{Rail}_{i,j} 
                                     + w_2\text{Water}_{i,j} 
                                     + w_3\text{Highway}_{i,j} \\
                                     &+ w_4\text{Major Street}_{i,j} 
                                     + w_5\text{Elementary School}_{i,j}\\ 
                                     & + w_6\text{High School}_{i,j}
                                     + w_7\text{Block Angle}_{i,j} \\
\end{align}

While the model for the populated neighboring blocks will be

\begin{align}
\phi(\mathbf{s}_{i,j}, \mathbf{w}) = & w_8 
                                     + w_9\text{Rail}_{i,j} 
                                     + w_{10}\text{Water}_{i,j} 
                                     + w_{11}\text{Highway}_{i,j}\\
                                     &+ w_{12}\text{Major Street}_{i,j} 
                                     + w_{13}\text{Elementary School}_{i,j}\\
                                     &+ w_{14}\text{High School}_{i,j} 
                                     + w_{15}\text{Block Angle}_{i,j}\\
                                     &+ w_{16}\text{Family Structure}_{i,j}
                                     + w_{17}\text{Race and Ethnicity}_{i_j}\\
                                     &+ w_{18}\text{Age Structure}  
                                     + w_{19}\text{Housing Structure}
\end{align}

We can combine these models by creating a dummy variable that takes a
value of 1 if neighboring block have sufficient population to support
the demographic distance measures, and 0 if the neighboring blocks do
not. We'll interact this dummy with the populated model and add the
variables to our unpopulated model.

\begin{align}
\phi(\mathbf{s}_{i,j}, \mathbf{w}) =  & w_0 
                                     + w_1\text{Rail}_{i,j} 
                                     + w_2\text{Water}_{i,j} 
                                     + w_3\text{Highway}_{i,j} \\
                                     &+ w_4\text{Major Street}_{i,j} 
                                     + w_5\text{Elementary School}_{i,j}\\ 
                                     & + w_6\text{High School}_{i,j}
                                     + w_7\text{Block Angle}_{i,j} \\
                                     &+ \text{Populated Blocks}_{i,j}\cdot\\
                                     &\quad (w_8
                                     + w_9\text{Rail}_{i,j} 
                                     + w_{10}\text{Water}_{i,j}\\ 
                                     &\quad+ w_{11}\text{Highway}_{i,j}
                                     + w_{12}\text{Major Street}_{i,j}\\ 
                                     &\quad + w_{13}\text{Elementary School}_{i,j} 
                                     + w_{14}\text{High School}_{i,j}\\ 
                                     &\quad + w_{15}\text{Block Angle}_{i,j}
                                     + w_{16}\text{Family Structure}_{i,j}\\
                                     &\quad + w_{17}\text{Race and Ethnicity}_{i_j}
                                     + w_{18}\text{Age Structure}\\  
                                     &\quad+ w_{19}\text{Housing Structure})\\
\end{align}

\section*{Results}

After estimating the model using the pystruct\footnote{\url{https://github.com/pystruct/pystruct/tree/rand_loss}}

<<weightTable, results='asis', cache=TRUE>>=
setwd('../code/training/')
weights <- read.table("weights.csv")
names(weights) <- dimnames(M)[[2]] 
no_pop <- c(weights[c('(Intercept)', 
                      'rail', 
                      'water', 
                      'highway', 
                      'grid_street', 
                      'elementary_school', 
                      'high_school', 
                      'block_angle')])

pop <- c(weights[c('sufficient_pop', 
                   'sufficient_pop:rail', 
                   'sufficient_pop:water', 
                   'sufficient_pop:highway', 
                   'sufficient_pop:grid_street', 
                   'sufficient_pop:elementary_school', 
                   'sufficient_pop:high_school', 
                   'sufficient_pop:block_angle')])

pop <- c(as.numeric(pop) 
         + as.numeric(no_pop), 
         weights[c('sufficient_pop:js_family', 
                   'sufficient_pop:js_race', 
                   'sufficient_pop:js_age', 
                   'sufficient_pop:js_housing')])

no_pop <- c(no_pop, rep(NA, 4))

models <- cbind(no_pop, pop)

rownames(models) <- c('(Intercept)', 
                      'Railroad', 
                      'Water', 
                      'Highway', 
                      'Major Street', 
                      'Elementary School', 
                      'High School', 
                      'Block Angle', 
                      'Family Structure', 
                      'Race and Ethnicity', 
                      'Age Structure', 
                      'Housing Structure')



models['Highway', "pop"] <- NA

WT <- xtable(models, digits=4)
print(WT)
@ 


\begin{figure}
<<plotPredictions, echo=FALSE, dev='pdf', message=FALSE>>=
setwd('../code/training/')
source('plot_predictions.R')
setwd(CURDIR)
@ 
\caption{Predicted Neighborhoods}
\end{figure}


\begin{figure}
\includegraphics{../code/training/predicted_chicago_neighborhoods.pdf}
\end{figure}


\begin{figure}
\includegraphics{../code/training/predicted_chicago_neighborhoods_ca.pdf}
\end{figure}

\end{document}
